# Build Workflow - clsecure

## Overview

**clsecure** uses a hybrid development/distribution model:
- **Development**: Work with modular source (`clsecure-src` + `lib/*.sh`)
- **Distribution**: Single-file `clsecure` (generated by `build.sh`)

## Why This Approach?

1. **Maintainability**: Modular code is easier to work with
2. **Backwards Compatibility**: Users download a single file (no directory structure needed)
3. **Distribution**: Simple installation (`curl` to a single file)

## Build Process

### Manual Build

```bash
# Rebuild clsecure from modules
./build.sh

# Verify the build
bash -n clsecure
./clsecure --help
```

### Automated Build (Pre-commit Hook)

The pre-commit hook automatically:
1. Runs `build.sh` before each commit
2. Verifies `clsecure` matches the source
3. Fails the commit if out of sync

**To bypass** (not recommended):
```bash
git commit --no-verify
```

## Workflow Options

### Option 1: Commit Built File (Current)

**Pros:**
- ✅ Single-file distribution always available
- ✅ Users can download directly from repo
- ✅ No build step needed for users
- ✅ Pre-commit hook ensures consistency

**Cons:**
- ⚠️ Must rebuild before committing
- ⚠️ Git tracks generated file (larger diffs)

**Workflow:**
```bash
# 1. Edit modules
vim lib/worker.sh
vim clsecure-src

# 2. Rebuild (or let pre-commit do it)
./build.sh

# 3. Commit (pre-commit verifies build)
git add clsecure-src lib/ build.sh clsecure
git commit -m "Update worker module"
```

### Option 2: Build on Release Only

**Pros:**
- ✅ Cleaner git history (no generated files)
- ✅ Smaller repository

**Cons:**
- ⚠️ Users need to build before using
- ⚠️ More complex distribution

**Workflow:**
```bash
# Development: commit only source
git add clsecure-src lib/ build.sh
git commit -m "Update worker module"

# Release: build and tag
./build.sh
git add clsecure
git commit -m "Build for release"
git tag v1.0.0
```

### Option 3: CI/CD Build (Recommended for Production)

**Pros:**
- ✅ Automated builds
- ✅ Verified consistency
- ✅ Release artifacts

**Cons:**
- ⚠️ Requires CI/CD setup

**Workflow:**
```bash
# Development: commit only source
git add clsecure-src lib/ build.sh
git commit -m "Update worker module"
git push

# CI/CD: automatically builds and creates release
# GitHub Actions runs build.sh and creates release artifact
```

## Current Setup

We're using **Option 1** with a pre-commit hook:

1. **Pre-commit hook** (`/.git/hooks/pre-commit`):
   - Automatically runs `build.sh`
   - Verifies `clsecure` matches source
   - Prevents commits if out of sync

2. **Manual build** when needed:
   ```bash
   ./build.sh
   ```

3. **Both files committed**:
   - `clsecure-src` (source)
   - `clsecure` (built)

## Recommendations

### For Development
- ✅ Keep pre-commit hook (ensures consistency)
- ✅ Edit `clsecure-src` and `lib/*.sh`
- ✅ Let pre-commit handle rebuilds

### For Releases
- ✅ Consider CI/CD to build release artifacts
- ✅ Tag releases with version numbers
- ✅ Document build process in release notes

### For Users
- ✅ Download `clsecure` directly (single file)
- ✅ No build step required
- ✅ Simple installation

## Troubleshooting

### Build fails
```bash
# Check syntax
bash -n clsecure-src
bash -n lib/*.sh

# Rebuild manually
./build.sh
```

### Pre-commit fails
```bash
# Rebuild manually
./build.sh

# Stage the updated file
git add clsecure

# Commit again
git commit -m "Your message"
```

### Want to skip pre-commit
```bash
# Not recommended, but possible
git commit --no-verify
```

## Summary

**Current State:**
- ✅ Modular development (`clsecure-src` + `lib/`)
- ✅ Single-file distribution (`clsecure`)
- ✅ Automated build verification (pre-commit hook)
- ✅ Both source and built files in repository

**This ensures:**
- Developers work with maintainable modules
- Users get a simple single-file script
- Build consistency is automatically verified
